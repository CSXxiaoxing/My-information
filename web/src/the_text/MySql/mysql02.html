<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <style type="text/css">
            *{margin:0;padding:0;}
            /*ul,li{list-style:none;}*/
            table{border-collapse:collapse;width:95%;margin:0px auto;color:#333;}
            th{height:40px;line-height:40px;text-align:center;font-size:16px;color:#333;}
            th,td{border:1px solid #333;text-align: center;}
            td{padding:10px;}
            .left,.right{width:90%;background: #5cb85c;}
            .center{background:#5bc0de;}
            .td-left,.td-right{text-align:left;font-size:14px;line-height:30px;}
            /*.td-center{background:#5bc0de;}*/
            ul li{margin-left:30px;}
            .code{background:#1086FF;color:#fff;padding:2px 5px;}
            .example{background:#58bc58;color:#fff;padding:2px 5px;}
            pre{background:#5cb85c;color:#fff;}
            .indent{text-indent: 20px;}
            .indent-sub{text-indent: 40px;}
            .margin-ul{margin-left: 40px;}
        </style>
    </head>
    <body>
        <table>
            <tr>
                <th class='center'>比较项</th>
                <th class='left'>MySql</th>
                <!-- <th class='right'>MongoDB</th> -->
            </tr>
            <tr>
              <td class='td-center'>介绍</td>
                <td class='td-left'>
                    <p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
                    <b>优点</b>
                    <ul>
                        <li>Mysql是开源的，所以你不需要支付额外的费用。</li>
                        <li>Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
                        <li>MySQL使用标准的SQL数据语言形式。</li>
                        <li>Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</li>
                        <li>Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。</li>
                        <li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</li>
                        <li>Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。</li>
                    </ul>
                    <b>缺点</b>
                    <ul>
                        <li>关系表的不灵活性</li>
                        <li>存储引擎混乱</li>
                    </ul>
                </td>
                
                <!-- <td class='td-right'>
                    <p>
                        MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。
                        在高负载的情况下，添加更多的节点，可以保证服务器性能。
                        MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。
                        MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
                    </p>
                    <b>优点</b>
                    <ul>
                        <li>MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。</li>
                        <li>你可以在MongoDB记录中设置任何属性的索引来实现更快的排序。</li>
                        <li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li>
                        <li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li>
                        <li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 </li>
                        <li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li>
                        <li>MongoDB安装简单。</li>
                    </ul>
                    <b>缺点</b>
                    <ul>
                        <li>不支持事务操作</li>
                        <li>占用空间过大</li>
                        <li>没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方</li>
                    </ul>
                </td> -->
            </tr>
            <tr>
                <td class='td-center'>创建数据库</td>
                <td class='td-left'>
                    <p>
                        基本语法：
                        <span class='code'>create database + 数据库名称 + [库选项]</span>
                    </p>
                    <p>其中，库选项是用来约束数据库的，为可选项（有默认值），共有两种，分别为：</p>
                    <ul>
                    <li>字符集设定：<code>charset/ character set</code>+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括<code>GBK</code>和<code>UTF8</code>等。</li>
                    <li>校对集设定：<code>collate</code>+ 具体校对集，表示数据比较的规则，其依赖字符集。</li>
                    </ul>
                    <p>示例：<span class='example'>create database testdata charset utf8</span></p>

                    <p>如果要检查数据库列表，请使用命令： <span class='code'>show databases</span></p>
                </td>
                
                <!-- <td class='td-right'>
                    <p>
                        基本语法：
                        <span class='code'>use DATABASE_NAME</span>
                    </p>
                    <p>示例：<span class='example'>use newdb</span></p>
                    <p>如果要检查数据库列表，请使用命令： <span class='code'>show dbs</span></p>
                    <p>注：空的数据库是不显示出来的</p>
                </td> -->
            </tr>
            <tr>
                <td class='td-center'>创建数据库表</td>
                <td class='td-left'>
                    <p>
                        基本语法：
                        <span class='code'>create table [if not exists] + 表名(字段名称 数据类型)[表选项];</span>
                    </p>
                    <p>其中，<code>if not exists</code>表示</p>
                    <ul>
                    <li>如果表名不存在，就执行创建代码；如果表名存在，则不执行创建代码。</li>
                    </ul>
                    <p>表选项则是用来控制表的表现形式的，共有三种，分别为：</p>
                    <ul>
                    <li>字符集设定：<code>charset/ character set</code>+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括<code>GBK</code>和<code>UTF8</code>等。</li>
                    <li>校对集设定：<code>collate</code>+ 具体校对集，表示数据比较的规则，其依赖字符集。</li>
                    <li>存储引擎：<code>engine</code>+具体存储引擎，默认为<code>InnoDB</code>，常用的还有<code>MyISAM</code>.</li>
                    </ul>
                    <P>
                        示例：
                        <pre> create table students
                          （
                            id int unsigned not null auto_increment primary key,
                            name char(8) not null,
                            sex char(4) not null,
                            age tinyint unsigned not null,
                            tel char(13) null default "-"
                          );
                                </pre>
                    <details>
                      <summary><b>语句解说:</b></summary>
                      <p style="font-size: 16px;">create table tablename(columns) 为创建数据库表的命令, 列的名称以及该列的数据类型将在括号内完成;</p>
                      <p style="font-size: 16px;">括号内声明了5列内容, id、name、sex、age、tel为每列的名称, 后面跟的是数据类型描述, 列与列的描述之间用逗号(,)隔开;</p>
                      <p><span style="font-size: 16px;">以 "id int unsigned not null auto_increment primary key" 行进行介绍:</span></p>
                      <ul style="padding-left: 3em; font-family: 微软雅黑;">
                      <li><span style="font-size: 16px;">"id" 为列的名称;</span></li>
                      <li><span style="font-size: 16px;">"int" 指定该列的类型为 int(取值范围为 -8388608到8388607), 在后面我们又用 "unsigned" 加以修饰, 表示该类型为无符号型, 此时该列的取值范围为 0到16777215;</span></li>
                      <li><span style="font-size: 16px;">"not null" 说明该列的值不能为空, 必须要填, 如果不指定该属性, 默认可为空;</span></li>
                      <li><span style="font-size: 16px;">"auto_increment" 需在整数列中使用, 其作用是在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。</span></li>
                      <li><span style="font-size: 16px;">"primary key" 表示该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。</span></li>
                      </ul>
                      <p><span style="font-size: 16px;">下面的 char(8) 表示存储的字符长度为8, tinyint的取值范围为 -127到128, default 属性指定当该列值为空时的默认值。</span></p>
                    </details>
                </td>
                
                <!-- <td class='td-right'>
                    <p>
                        基本语法：<span class='code'>db.createCollection(name，options)</span>
                    </p>
                    <p>在命令中，name 是要创建的集合的名称。 options是一个文档，用于指定集合的配置。</span></p>
                    <p>在实际应用中，mongodb是不需要创建集合。当插入一些文档时，MongoDB 会自动创建集合。</p>
                </td> -->
            </tr>
            <tr>
              <td class='td-center'>增--数据操作</td>
               <td class='td-left'>
                   <p>基本语法：<span class='code'>insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...)</span></p>
                   <p>对于数据的新增操作，有两种方法</p>
                   <ul>
                        <li><strong>第 1 种</strong>：给全表字段插入数据，不需要指定字段列表，但要求数据的值出现的顺序必须与表中的字段出现的顺序一致，并且凡是非数值数据，都需要用引号（建议使用单引号）括起来。 <br>
                   <ul>
                       <li>基本语法：<span class='code'>insert into + 表名 + values(值列表)[,(值列表)];</span></li>
                       <li>示例：<span class='code'>insert into testdata valus('charies',18,'3.1');</span></li></ul></li>
                       <li><strong>第 2 种</strong>：给部分字段插入数据，需要选定字段列表，字段列表中字段出现的顺序与表中字段的顺序无关，但值列表中字段值的顺序必须与字段列表中的顺序保持一致。 <br>
                       <ul><li>基本语法：<span class='code'>insert into + 表名(字段列表) + values(值列表)[,(值列表)];</span></li>
                       <li>示例：<span class='code'>insert into testdata (age,name) values (18,'guo');</span></li></ul></li>
                   </ul>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
              <td class='td-center'>改--数据操作</td>
               <td class='td-left'>
                   <p>基本语法：<span class='code'>update + 表名 + set + 字段 = 值 + [where 条件]</span>
                   <p>示例：<span class='example'>UPDATE student SET age=22 WHERE NAME='dk'</span>
                   <p>在这里，建议尽量加上where条件，否则的话，操作的就是全表数据。</p>
                   <p>此外，判断更新操作是否成功，并不是看 SQL 语句是否执行成功，而是看是否有记录受到影响，即affected的数量大于1时，才是真正的更新成功。</p>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
              <td class='td-center'>删--数据操作</td>
               <td class='td-left'>
                   <p>基本语法：<span class='code'>delete from + 表名 + [where 条件]</span>
                   <p>示例：<span class='example'>delete from student where grade = '100'</span>
                   <p>当然，我们也可以用drop来实现删除操作，不过与delete相比，drop的威力更强，其在执行删除操作的时候，不仅会删除数据，还会删除定义并释放存储空间；而delete在执行删除操作的时候，仅会删除数据，并不会删除定义和释放存储空间。</p>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
            <td class='td-center'>查--数据操作</td>
               <td class='td-left'>
                   <p>查看全部 –> 基本语法：<span class='code'>select * from + 表名 + [where 条件]</span>
                   <p>示例：<span class='example'>select * from student</span>
                   <p>查看部分 –> 基本语法：<span class='code'>select + 字段名称[,字段名称] + from + 表名 + [where 条件]</span>
                   <p>示例：<span class='example'>select name,age,grade from student where age = '18'</span>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
            <td class='td-center'>数据类型</td>
               <td class='td-left'>
                   <img src="img/datatype.jpg"  width="50%" alt="" />
                   <details>
                     <summary>数据类型详解</summary>
                     <div id="cnblogs_post_body"><p><strong>1、整型</strong></p>
                     <table style="width: 600px;" border="1" cellspacing="0" cellpadding="5">
                     <tbody>
                     <tr>
                     <td align="center" width="173"><strong>MySQL数据类型</strong></td>
                     <td align="center" width="418"><strong>含义（有符号）</strong></td>
                     </tr>
                     <tr>
                     <td>tinyint(m)</td>
                     <td>1个字节&nbsp; 范围(-128~127)</td>
                     </tr>
                     <tr>
                     <td>smallint(m)</td>
                     <td>2个字节&nbsp; 范围(-32768~32767)</td>
                     </tr>
                     <tr>
                     <td>mediumint(m)</td>
                     <td>3个字节&nbsp; 范围(-8388608~8388607)</td>
                     </tr>
                     <tr>
                     <td>int(m)</td>
                     <td>4个字节&nbsp; 范围(-2147483648~2147483647)</td>
                     </tr>
                     <tr>
                     <td>bigint(m)</td>
                     <td>8个字节&nbsp; 范围(+-9.22*10的18次方)</td>
                     </tr>
                     </tbody>
                     </table>
                     <p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。 <br>int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。</p>
                     <p><strong>2、浮点型(float和double)</strong></p>
                     <table style="width: 600px;" border="1" cellspacing="0" cellpadding="5">
                     <tbody>
                     <tr>
                     <td align="center" width="173">    <strong>MySQL数据类型</strong></td>
                     <td align="center" width="418"><strong>含义</strong></td>
                       </tr>
                     <tr>
                     <td width="151">float(m,d)</td>
                     <td width="427">单精度浮点型&nbsp;&nbsp;&nbsp; 8位精度(4字节)&nbsp;&nbsp;&nbsp;    &nbsp;m总个数，d小数位 </td>
                       </tr>
                     <tr>
                     <td width="151">double(m,d)</td>
                     <td width="427">双精度浮点型&nbsp;&nbsp;&nbsp; 16位精度(8字节)&nbsp;&nbsp;    &nbsp;m总个数，d小数位 </td>
                       </tr>
                     </tbody>
                     </table>
                     <p>
                     设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。</p>
                     <p><strong>3、定点数</strong></p>
                     <p>
                      浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 <br> decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。</p>
                     <p><strong>4、字符串(char,varchar,_text) </strong></p>
                     <table style="width: 600px;" border="1" cellspacing="0" cellpadding="5">
                     <tbody>
                     <tr>
                     <td align="center" width="173">      <strong>MySQL数据类型</strong></td>
                     <td align="center" width="418"><strong>含义</strong></td>
                       </tr>
                     <tr>
                     <td width="146">char(n)</td>
                     <td width="428">固定长度，最多255个字符 </td>
                       </tr>
                     <tr>
                     <td width="146">varchar(n)</td>
                     <td width="428">固定长度，最多65535个字符 </td>
                       </tr>
                     <tr>
                     <td width="146">tinytext</td>
                     <td width="428">可变长度，最多255个字符 </td>
                       </tr>
                     <tr>
                     <td width="146">text</td>
                     <td width="428">可变长度，最多65535个字符 </td>
                       </tr>
                     <tr>
                     <td width="146">mediumtext</td>
                     <td width="428">可变长度，最多2的24次方-1个字符 </td>
                       </tr>
                     <tr>
                     <td width="146">longtext</td>
                     <td width="428">可变长度，最多2的32次方-1个字符 </td>
                       </tr>
                     </tbody>
                     </table>
                     <p>
                     char和varchar：<br>  1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 <br>  2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 <br>3.char类型的字符串检索速度要比varchar类型的快。<br><br>   varchar和text： <br>  1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 <br>  2.text类型不能有默认值。 <br>  3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</p>
                     <p><strong>5.二进制数据(_Blob)</strong></p>
                     <p>
                       1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 <br>  2._BLOB存储的数据只能整体读出。 <br>  3._TEXT可以指定字符集，_BLO不用指定字符集。</p>
                     <p><strong>6.日期时间类型</strong></p>
                     <table style="width: 600px;" border="1" cellspacing="0" cellpadding="5">
                     <tbody>
                     <tr>
                     <td align="center" width="173">    <strong>MySQL数据类型</strong></td>
                     <td align="center" width="418"><strong>含义</strong></td>
                       </tr>
                     <tr>
                     <td>date</td>
                     <td>日期 '2008-12-2'</td>
                       </tr>
                     <tr>
                     <td>time</td>
                     <td>时间 '12:25:36'</td>
                       </tr>
                     <tr>
                     <td>datetime</td>
                     <td>日期时间 '2008-12-2 22:06:44'</td>
                       </tr>
                     <tr>
                     <td>timestamp</td>
                     <td>自动存储记录修改时间 </td>
                       </tr>
                     </tbody>
                     </table>
                     <p>
                     若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p>
                     <p><strong>数据类型的属性</strong></p>
                     <p>&nbsp;</p>
                     <table style="width: 600px;" border="1" cellspacing="0" cellpadding="5">
                     <tbody>
                     <tr>
                     <td align="center" width="173">      <strong>MySQL关键字</strong></td>
                     <td align="center" width="418"><strong>含义</strong></td>
                       </tr>
                     <tr>
                     <td>NULL </td>
                     <td>数据列可包含NULL值 </td>
                       </tr>
                     <tr>
                     <td>NOT NULL </td>
                     <td>数据列不允许包含NULL值 </td>
                       </tr>
                     <tr>
                     <td>DEFAULT </td>
                     <td>默认值</td>
                       </tr>
                     <tr>
                     <td>PRIMARY KEY </td>
                     <td>主键 </td>
                       </tr>
                     <tr>
                     <td>AUTO_INCREMENT </td>
                     <td>自动递增，适用于整数类型 </td>
                       </tr>
                     <tr>
                     <td>UNSIGNED </td>
                     <td>无符号 </td>
                       </tr>
                     <tr>
                     <td>CHARACTER SET name </td>
                     <td>指定一个字符集 </td>
                       </tr>
                     </tbody>
                     </table></div>
                   </details>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
            <td class='td-center'>蠕虫复制</td>
               <td class='td-left'>
                   <p>蠕虫复制：从已有的数据表中获取数据，然后将数据进行新增操作，数据成倍（以指数形式）的增加</p>
                   <p>基本语法：<span class='code'>insert into + 表名 + [()] + select + 字段列表/* + from + 表名</span>
                   <p>示例：<span class='example'>insert into my_copy select * from my_collate_bin</span>
                   <p>蠕虫复制的意义：</p>
                   <ul>
                       <li>从已有的数据表中拷贝数据到新的数据表</li>
                       <li>可以迅速的让表中的数据膨胀到一定的数量级，多用于测试表的压力及效率</li>
                   </ul>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
            <tr>
            <td class='td-center'>高级查询</td>
               <td class='td-left'>
                   <p>基本语法：<span class='code'>select + [select 选项] + 字段列表[字段别名]/* + from + 数据源 + [where 条件] + [1] + [2] + [3]</span></p>
                   <ul>
                       <li>[1] = [group by 子句]</li>
                       <li>[2] = [order by 子句]</li>
                       <li>[3] = [limit 子句]</li>
                   </ul>
                   <br>
                   <details>
                     <summary><b>1.select选项</b>，即select对查出来的结果的处理方式</summary>
                      <ul>
                          <li>all：默认，保留所有的查询结果</li>
                          <li>distinct：去重，将查出来的结果中所有字段都相同的记录去除</li>
                      </ul>
                   </details>
                   <br>
                   <details>
                     <summary><b>2.字段别名</b>，即当数据进行查询的时候，有时候字段的名字并不一定满足需求（特别地，在多表查询的时候，很可能会有同名字段），这时就需要对字段进行重命名、取别名。</summary>
                     <p class='indent'>基本语法：<span class='code'>字段名 + [as] + 别名</span></p>
                     <p class='indent'>示例：<span class='example'>name as 姓名</span></p>
                   </details>
                   <br />
                   <details>
                     <summary><b>3.数据源</b>，即数据的来源，关系型数据库的数据源都是数据表，本质上只要保证数据类似二维表，最终就可以作为数据源。</summary>
                      <p class='indent'>数据源分为 3 种，分别为：单表数据源，多表数据源和查询语句</p>
                      <p class='indent'>第 1 种：单表数据源</p>
                      <p class='indent-sub'>基本语法：<span class='code'>select * from + 表名;</span></p>
                      <p class='indent'>第 2 种：多表数据源</p>
                      <p class='indent-sub'>基本语法：<span class='code'>select * from + 表名1,表名2...;</span></p>
                      <p class='indent'>第 3 种：查询语句（子查询）</p>
                      <p class='indent-sub'>基本语法：<span class='code'>select * from + (select * from + 表名) + [as] + 别名;</span></p>
                   </details>
                   <br>
                   <details>
                     <summary><b>4.where字句</b>：用来判断数据和筛选数据，返回的结果为0或者1，其中0代表false，1代表true，where是唯一一个直接从磁盘获取数据的时候就开始判断的条件，从磁盘中读取一条数据，就开始进行where判断，如果判断的结果为真，则保持，反之，不保存。</summary>
                     <h4 class='indent'>判断条件：</h4>
                      <ul>
                          <li>比较运算符：>、<、>=、<=、<>、=、like、between and、in和not in；</li>
                          <li>逻辑运算符：&&、||、和!</li>
                      </ul>
                      <p class='indent-sub'>示例：<span class='example'>select * from student where id = 2 || id = 3 || id = 5;</span></p>
                      <p class='indent-sub'>示例：<span class='example'>select * from student where id in (2,3,5);</span></p>
                      <p class='indent-sub'>示例：<span class='example'>select * from student where id between 2 and 5</span></p>
                   </details>
                    <br>
                    <details>
                        <summary><b>5.group by子句</b></summary>
                        <h4 class='indent'>group by子句：根据表中的某个字段进行分组，即将含有相同字段值的记录放在一组，不同的放在不同组。</h4>
                        <p class='indent'>基本语法：<span class='code'>group by + 字段名;</span></p>
                        <p class='indent'>示例：<span class='example'>select * from dishname group by classify;</span></p>
                        <h4  class='indent'>为了方便统计数据，SQL 提供了一系列的统计函数，例如：</h4>
                        <ul class='margin-ul'>
                            <li>cout()：统计分组后，每组的总记录数；</li>
                            <li>max()：统计每组中的最大值；</li>
                            <li>min()：统计每组中的最小值</li>
                            <li>avg()：统计每组中的平均值</li>
                            <li>sum()：统计每组中的数据总和</li>
                        </ul>
                        <p class='indent'>示例：<span class='example'>select classify,count(*),max(age),min(age),avg(age),sum(age) from dishname group by classify;</span></p>
                    </details>
                    <br>
                    <details>
                          <summary><b>6.order by子句</b></summary>
                          <h4 class='indent'>order by子句：根据某个字段进行升序或者降序排序，依赖校对集。</h4>
                          <p class='indent'>基本语法：<span class='code'>order by + 字段名 + [asc/desc]</span></p>
                          <p class='indent'>其中，asc为升序，为默认值；desc为降序。</p>
                          <p class='indent-sub'>示例：<span class='example'>select * from dishname order by number;</span></p>
                          <h4 class='indent'>此外，咱们可以进行「多字段排序」，即先根据某个字段进行排序，然后在排序后的结果中，再根据某个字段进行排序。</h4>
                          <p class='indent-sub'>示例：<span class='example'>select * from dishname order by classify,price desc;</span></p>
                    </details>
                    <br>
                    <details>
                      <summary><b>7.limit子句</b></summary>
                          <h4 class='indent'>limit子句：是一种限制结果的语句，通常来限制结果的数量。</h4>
                          <p class='indent'>基本语法：<span class='code'>limit + [offset] + length</span></p>
                          <p class='indent'>其中，offset为起始值；length为长度。</p>
                          <h4 class='indent'>三种用法</h4>
                          <h4 class='indent-sub'>第 1 种：只用来限制长度（数据量）</h4>
                          <h4 class='indent-sub'>第 2 种：限制起始值，限制长度（数据量）</h4>
                          <h4 class='indent-sub'>第 3 种：主要用来实现数据的分页，目的是为用户节省时间，提高服务器的相应效率，减少资源的浪费）</h4>
                          <ul class='margin-ul'>
                              <li>length：表示每页的数据量，基本不变；</li>
                              <li>offset：表示每页的起始值，公式为offset=(页码-1)*length.</li>
                          </ul>
                    </details>
               </td>
               
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>


            <tr>
               <td class='td-center'>其他</td>
               <td class='td-left'>
                  <h4>1.随机抽取</h4>
                   <p>基本语法：<span class='code'>SELECT 字段列表[字段别名] FROM 表名 ORDER BY RAND() [LIMIT]</span>
                   <p class='indent-sub'>示例：<span class='example'>SELECT * FROM dishname ORDER BY RAND() LIMIT 1;</span></p>
                   <h4>2.存入当前时间</h4>
                   <p>基本语法：<span class='code'>insert into 表名 (时间字段) values (now())</span>
                   <p class='indent-sub'>示例：<span class='example'>INSERT INTO dishname (NAME,classify,number,price,TIME,picture,creatDate,STATUS) VALUES ('冰红茶','饮料','100003','3','1','',NOW(),'正在卖')</span></p>
               </td>
               <!-- <td class='td-right'>
                    <p>基本语法：<span class='code'>db.COLLECTION_NAME.insert(document)</span></p>
               </td> -->
            </tr>
        </table>

    </body>
</html>